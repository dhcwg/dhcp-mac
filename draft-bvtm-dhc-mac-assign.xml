<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="std" docName="draft-bvtm-dhc-mac-assign-00">
  <front>
    <title abbrev="MAC address assignment in DHCPv6">
    Link Layer Addresses Assignment Mechanism for DHCPv6</title>

    <author fullname="Bernie Volz" initials="B" surname="Volz">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>1414 Massachusetts Ave</street>
          <city>Boxborough, MA 01719</city>
          <country>USA</country>
        </postal>
        <email>volz@cisco.com</email>
      </address>
    </author>

    <author fullname="Tomek Mrugalski" initials="T."
            surname="Mrugalski">
      <organization abbrev="ISC">Internet Systems Consortium,
      Inc.</organization>
      <address>
        <postal>
          <street>950 Charter Street</street>
          <city>Redwood City</city>
          <region>CA</region>
          <code>94063</code>
          <country>USA</country>
        </postal>
        <email>tomasz.mrugalski@gmail.com</email>
      </address>
    </author>

    <date year="2018"/>

    <area>Internet</area>

    <workgroup>Dynamic Host Configuration (DHC)</workgroup>

    <keyword>DHCPv6</keyword>

    <keyword>Link-layer</keyword>

    <keyword>assignment</keyword>

    <!--  SECTION 0:  Abstract                      -->

    <abstract>
      <t>In certain environments, e.g. large scale virtualisation
      deployments, new devices are created in automated manner. Such
      devices typically have their link layer (MAC) addresses
      randomised. With sufficient scale the likelihood of collision is
      not acceptable. Therefore an allocation mechanism is
      required. This draft proposes an extension to DHCPv6 that allows
      a scalable approach to link layer address assignments.</t>

    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <!-- 1, line 230-->

      <t>There are several new deployment types that deal with a large
      number of devices that need to initialised. One of them is a
      scenario where VM (virtual machines) are created on a massive
      scale. Typically the new VM instances are assigned a random link
      layer (MAC) address, but that does not scale well due to
      birthday paradox. Another use case are IOT devices. Typically
      there is no need to provide global uniqueness of MAC addresses
      for such devices. On the other hand, huge number of such devices
      would likely exhaust a vendor's OUI (Organisation's Unique
      Identifier) global address space. For those reasons, it is
      desired to have some form of local authority that would be able
      to assign MAC addresses.</t>

      <t>The IEEE originally set aside half of the 48-bit MAC Address
      space for local use (where the U/L bit is set to 1). In 2017, the
      IEEE specified an optional specification (IEEE 802c) that divides
      this space into quadrants (Standards Assigned Identifier, Extended
      Local Identifier, Administratively Assigned Identifier, and a
      Reserved quadrant) - more details are in <xref
      target="IEEE802cSummary"/>. The IEEE is also
      working to specify protocols and procedures for assignment of
      locally unique addresses (IEEE 802.1cq). This work may serve
      as one such protocol for assignment. For additional background,
      see <xref target="IEEE-802-Tutorial"/>.</t>

      <t>This document proposes a new mechanism that extends DHCPv6
      operation to handle MAC address assignments.</t>

      <t>Since DHCPv6 (<xref target="RFC3315"/>) is a protocol that can
      allocate various types
      of resources (non-temporary addresses, temporary addresses,
      prefixes, but also many options) and has necessary
      infrastructure to maintain such assignment, it is a good
      candidate for the desired functionality.</t>
    </section>

    <section anchor="requirements" title="Requirements">
      <t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be interpreted as
      described in BCP 14 <xref target="RFC2119"/> <xref
      target="RFC8174" /> when, and only when, they
      appear in all capitals, as shown here.</t>
    </section>

    <section anchor="terminology" title="Terminology">

      <t>The DHCPv6 terminology relevant to this specification from the DHCPv6
      Protocol <xref target="RFC3315"/> applies here.</t>

      <t>
        <list hangIndent="26" style="hanging">
          <t hangText="client">A device that is interested in
          obtaining MAC addresses. It implements DHCPv6 a limited
          client functionality with the additional mechanisms
          specified in this document.</t>
          <t hangText="server">A software that manages MAC address
          allocation and is able respond to client queries. It
          implements DHCPv6 server functionality as described in <xref
          target="RFC3315"/>, with the additional mechanisms specified
          in this document.</t>
          <t hangText="address">Unless specified otherwise, an address
          means a link-layer (or MAC) address, as defined in IEEE802.
          The address is typically 6 bytes long, but some network
          architectures may use different lengths.</t>
        </list>
      </t>

    </section>

    <section anchor="overview" title="Mechanism overview">

      <t>This mechanism is designed to be generic and usable in many
      deployments, but there are two scenarios it attempts to address
      in particular. The first one pertains to large scale
      virtualization. In such environments the governing entity
      often called hypervisor is frequently required to spawn
      new VMs (virtual machines). The hypervisor needs to assign
      new MAC addresses to those machines. It acts as a DHCP client
      and requests available DHCP servers to assign one or more MAC
      addresses (an address range). Hypervisor does not use those
      addresses by itself, but rather uses them to create new VMs with
      appropriate MAC addresses. It is worth pointing out a cumulative
      nature of scenario. Over time hypervisor is likely to increase
      its MAC addresses usage. While some obsolete VMs will be
      deleted and their MAC addresses will become eligible for
      release, it is unexpected for all MAC addresses to be ever
      released.</t>

      <t>Another usage scenario is related to IOT (Internet of
      Things). With emergence of IOT solution a new class of cheap,
      sometimes short lived and disposable devices has
      emerged. Examples may include various sensors (e.g. medical) and
      actuators or controllable LED lights. Upon first boot, the
      device uses temporary MAC address, as described in
      <xref target="IEEEStd802c-2017"/>, to send initial DHCP packets to
      available DHCP servers. Such devices will typically request
      a single MAC address for each available network interface,
      which typically mean one MAC address per device. Once the server
      assigns a MAC address, the device abandons its temporary MAC
      address.</t>

      <t>In all scenarios the protocol operates in fundamentally the
      same way. The device requesting an address, acting as a DHCP
      client, will send Solicit message with IA_LL option to all
      available DHCP servers. Each server available will send an
      Advertise message with offered MAC address or addresses. The
      client will then pick the best server, as governed by
      <xref="RFC3315"/>, and will send Request message to that server.
      The server will then assign the MAC addresses and send a Reply
      message. Upon recection, the client can start using those MAC
      addresses.</t>

      <t>Normal DHCP mechanisms are in use. The client is expected
      to periodically renew the MAC addresses as governed by T1 and T2
      timers. This mechanism can be administratively disabled by
      setting T1 and T2 to infinite values.</t>

      <t>The client can release MAC addresses when they are no longer
      needed by sending a Release message.</t>

      <t>Confirm, Decline, Reconfigure and Information-Request
      messages are not used in MAC address assignment.</t>

      <!-- Q: Perhaps we could always use rapid-commit here? -->

      <t>DISCUSSION: Even though in scenarios with thousands of
      devices in place the birthday paradox dictates the collisions
      are likely, the short window of opportunity for the collision to
      actually occur alleviates the problem to a large degree.</t>

      <section title="Design assumptions">

      <t>One of the essential aspects of this mechanism is its
      cumulative nature, especially in the hypervisor scenario. The
      server-client relationship does not look like other DHCP
      transactions. This is especially true in hypervisor scenario. In
      typical environment there would be one server and rather small
      number of hypervisors, possibly even only one. However, over
      time the number of MAC addresses requested by a client will
      likely increase over time as new VMs are spawned.</t> -->

      <t>Another aspect crucial for efficient design is the
      observation that a single client acting as hypervisor will
      likely use thousands of addresses. Therefore an approach similar
      to what is used for address or prefix assignment (IA container
      with all assigned addresses listed, one option for each address)
      would not work well. Therefore the mechanism should operate on MAC
      address ranges, rather than single values. This does not prevent
      the users to treat individual MAC addresses as ranges with just
      one address.</t>
      </section>

      <section title="Requesting addresses">
        <t>Client sends the requested link-layer address in its packet
        as a hint. Several cases can be considered here. First, if the
        client doesn't have any previous link-layer addresses assigned
        and doesn't have any specific preferences, it can request any
        address, that is represented as values consisting of only
        zeroes.
        </t>

        <t>Client can represent a block of addresses, starting with
        the specified address and followed by a number of addresses
        indicated by extra-addresses field. If that field value is 0,
        then exactly one address is requested.</t>

        <t>Client can request a block of addresses, without specifying
        any particular preferences regarding starting address. This
        can be achieved using link-layer address consisting of all
        zeroes and extra-addresses field specifying the number of
        requested addresses decreased by one.</t>
      </section>

      <section title="Requesting Addresses">
        <t>The MAC addresses are assigned in groups. The smallest
        group is a single address. To request an assignment, client
        sends Solicit message with IA_LL container in it. Optionally,
        it may include LLADDR in it to signal some of its
        preferences: to request specific MAC address by filling
        link-layer-address field or requesting more than one address
        by sending non-zero value in extra-addresses field. A client
        that wishes to receive certain number of addresses, but has
        no preferrence regarding it, should send link-layer-len set to
        the lenght of the MAC address (typically 6 for most network
        architectures), zeroed link-layer-address and extra-addresses
        set to a value of desired addresses minus one.</t>

        <t>The server, upon receiving IA_LL container, inspects its
        content and may offer address or addresses according to its
        policy. The server MAY take into consideration the values
        client sent in LLADDR option. However, server MAY chose to
        ignore some or all of them. In paricular, the server may
        send a different address than requested, or grant a smaller
        number of addresses. Client sends back Advertise message
        containing LLADDR option that specifies address or address
        being offered. If the server is unable to provide any
        addresses it MUST include Status Code option (see
        <xref target="RFC3315" />, Section 22.13) with status set to
        NoAddrsAvail.</t>

        <t>The client MUST be able to handle a response that contains
        address or addresses different than those requested.</t>

        <t>Client waits for available servers to send Advertise
        responses and picks one server as defined in Section 17.1.3 of
        <xref target="RFC3315"/>. Client then sends Request message
        that includes IA_LL container option with the LLADDR option
        copied from the Advertise message sent by the chosen server.
        </t>

        <t>Upon reception of Request message with IA_LL container
        option, the server assigns requested addresses. The server MAY
        alter the allocation at this time. It then generates and sends
        a Reply message back to the client.</t>
        <!-- add references to 3315 regarding t1, t2 timers and
             appropriate sections that define how to transmit packets
             (client send to multicast, server to unicast, the relay
             mechanism etc.). Just add references, not -->

        <!-- should we mention rapid commit or preference 255 here? -->
      </section>

      <section title="Renewing and releasing addresses">
      <t>TODO: How client renews/releases? Make sure that the whole
      block is always renewed/released. Further fragments are not
      allowed.</t>

      <t>TODO:  The growth in hypervisor case. The hypervisor client
      will start with certain number of MAC addresses and then will
      keep asking for more over time. If we go with IAID approach, the
      client will be sending more and more options over time until MTU
      limit is hit. If we decide to go with a single container and
      multiple range options in it, we'll need some sort of compacting
      algorithm.</t>
      </section>

      <section title="Other questions">
      <t>TODO: What should the server do if client asks for X
      addresses, but for whatever reason (limited resources or policy), the
      server is only able to assign Y? Proposed answer: respond with
      a smaller block and add text: client MUST accept the value sent
      by client. If additional addresses are needed, send another
      request (but obey rate limiting).</t>

      <t>TODO: How exactly the Use Temporary MAC address for
      anonymity, IEEE 802.11-02/109r0 works? Can we turn this into a
      way to "upgrade" the temporary address into permanent one? "Yes,
      I confirm your temp address is really unique. You can keep it."</t>
      </section>
    </section>

    <section anchor="option" title="Option definitions">

      <t>This mechanism uses approach similar to existing mechanisms
      in DHCP. There is one container option (IA_LL) that contains
      the actual MAC address or addresses, represented by LLADDR
      option. Each such option represents an range, which is expressed
      as a first address with a number that specifies how many
      additional addresses are included.</t>

      <section anchor="IA_LL"
               title="Identity Association for Link-Layer Addresses Option">

      <figure align="center" anchor="ia-ll-syntax"
              title="IA_LL Option Syntax">
        <artwork align="left"><![CDATA[
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          OPTION_IA_LL         |          option-len           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        iaid (4 octets)                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          t1 (4 octets)                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          t2 (4 octets)                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   .                                                               .
   .                         IA_LL-options                         .
   .                                                               .
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ]]></artwork>
        <postamble></postamble>
      </figure>

        <t>
          <list hangIndent="16" style="hanging">
            <t hangText="option-code">OPTION_IA_LL (tbd1).</t>

            <t hangText="option-len">12 + length of IA_LL-options field.</t>

            <t hangText="iaid">The unique identifier for this IA_LL; the
                           IAID must be unique among the identifiers for
                           all of this client's IA_LLs.  The number
                           space for IA_LL IAIDs is separate from the
                           number space for other IA option types (i.e.,
                           IA_NA, IA_TA, and IA_PD). A four octets long field.</t>

            <t hangText="t1">The time at which the client should contact
                           the server from which the addresses in the
                           IA_LL were obtained to extend the lifetimes
                           of the addresses assigned to the IA_LL; T1 is
                           a time duration relative to the current time
                           expressed in units of seconds.  A four octets
                           long field.</t>

            <t hangText="t2">The time at which the client should contact
                           any available server to extend the lifetimes
                           of the addresses assigned to the IA_LL; T2 is
                           a time duration relative to the current time
                           expressed in units of seconds. A four octets
                           long field.</t>

            <t hangText="IA_LL-options">Options associated with this IA_LL.
                           A variable length field (12 octets less than
                           the value in the option-len field).</t>
          </list>
        </t>

      </section>

      <section anchor="LLADDR"
               title="Link Layer Addresses Option">

        <figure align="center" anchor="lladdr-syntax"
                title="LLADDR Option Syntax">
          <preamble></preamble>

          <artwork align="left"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          OPTION_LLADDR        |          option-len           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       link-layer-type         |        link-layer-len         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     link-layer-address                        |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      extra-addresses                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      valid-lifetime                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.                                                               .
.                      LLADDR-options                           .
.                                                               .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          <postamble></postamble>
        </figure>

        <t>
          <list hangIndent="16" style="hanging">
            <t hangText="option-code">OPTION_LLADDR (tbd2).</t>

            <t hangText="option-len">12 + link layer length
            (typically 6) + any LLADDR options. Assuming a typical
            link-layer address of 6 is used and there are no extra
            options, length should be equal to 18.</t>

            <t hangText="link-layer-type">The link-layer type MUST be a
            valid hardware type assigned by the IANA, as described in
            <xref target="RFC5494"/>. The type is stored in network
            byte order.</t>

            <t hangText="link-layer-len">Specifies the length of the
            link-layer-address field (typically 6, for a link-layer-type
            of 1 (Ethernet)). A two octets long field.</t>

            <t hangText="link-layer-address">Specific value of
            link-layer address that is being requested. A special case
            of address consisting of only zeroes means any
            address. This value can be only sent by a client that
            requests a new block. In responses from a server, this
            value specifies the first address allocated.</t>

            <t hangText="extra-addresses">Number of additional
            addresses that follow address specified in
            link-layer-address. For requesting a single address, use
            0. For example: link-layer-address: 02:04:06:08:0a and
            extra-addresses 3 designates a block of 4 addresses,
            starting from 02:04:06:08:0a (inclusive) and ending with
            02:04:06:08:0d (inclusive). In responses from a server,
            this value specifies the number of additional addresses
            allocated. A four octets long field.</t>

            <t hangText="valid-lifetime">The valid lifetime for the
            address(es) in the option, expressed in units of seconds.
            A four octets long field.</t>

            <t hangText="LLADDR-options">any encapsulated options that
            are specific to this particular LLBLOCK. Currently there
            are no such options defined, but they may appear in the future.</t>
          </list>
        </t>

      </section>

    </section>

    <section anchor="client" title="Client behaviour">
      <t>TODO: We need start this section by clearly defining what
      'client' means in this context (either hypervisor acting on
      behalf of the client to be spawned or the IOT device acting on
      its own behalf).</t>
    </section>

    <section anchor="server" title="Server behaviour">
      <t>TODO: Need to describe server operation. Likely also recommend
      assigning MAC addresses from an appropriate quandrant (see
      Appendix).</t>
    </section>

    <section anchor="iana" title="IANA Considerations">
      <t>IANA is kindly requested to assign new value for options
      OPTION_LL (tbd1) and OPTION_LLADDR (tbd2) and add those values
      to the DHCPv6 Option Codes registry maintainted at
      http://www.iana.org/assignments/dhcpv6-parameters.</t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>TODO:</t>
    </section>

    <section anchor="privacy" title="Privacy Considerations">
      <t>TODO: </t>
    </section>

  </middle>

  <back>
    <references title="Normative References">

      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.3315'?>
      <?rfc include='reference.RFC.8174'?>
    </references>

    <references title="Informative References">

      <?rfc include='reference.RFC.2464'?>
      <?rfc include='reference.RFC.5494'?>

      <reference anchor="IEEE-802-Tutorial">
        <front>
          <title>
              Emerging IEEE 802 Work on MAC Addressing,
              https://datatracker.ietf.org/meeting/96/materials/slides-96-edu-ieee802work-0/
              </title>

          <author fullname="Pat Thaler" initials="P" surname="Thaler"/>

          <date />
        </front>
      </reference>

      <reference anchor="IEEE-802.11-02/109r0">
        <front>
          <title>Temporary MAC address for anonymity,
          https://mentor.ieee.org/802.11/dcn/02/11-02-0109-00-000i-temporary-mac-address-for-anonymity.ppt</title>
          <author fullname="Jon Edney" initials="J." surname="Edney" />
          <author fullname="Henry Haverinen" initials="H." surname="Haverinen" />
          <author fullname="J-P" initials="J-P." surname="Honkanen" />
          <author fullname="Pekko" initials="P." surname="Orava" />
          <format type="TXT"
                  target="https://mentor.ieee.org/802.11/dcn/02/11-02-0109-00-000i-temporary-mac-address-for-anonymity.ppt" />
        </front>
      </reference>

      <reference anchor="IEEEStd802c-2017">
        <front>
          <title>
              IEEE Standard for Local and Metropolitan Area Networks: Overview and Architecture,
              Amendment 2: Local Medium Access Control (MAC) Address Usage, IEEE Std 802c-2017
              </title>

          <author>
            <organization>IEEE Computer Society</organization>
          </author>

          <date />
        </front>
      </reference>

    </references>

    <section anchor="IEEE802cSummary" title="IEEE 802c Summary">

      <t>This appendix provides a brief summary of IEEE802c from
           <xref target="IEEEStd802c-2017"/>.</t>

      <t>The original IEEE 802 specifications assigned half of the 48-bit MAC address
      space to local use -- these addresses have the U/L bit set to 1 and are locally
      administered with no imposed structure.</t>

      <t>In 2017, the IEEE issued the 802c specification which defines a new "optional
      Structured Local Address Plan (SLAP) that specifies different assignment
      approaches in four specified regions of the local MAC address space." Under this
      plan, there are 4 SLAP quadrants that use different assignment policies.</t>

      <t>The first octet of the MAC address Z and Y bits define the quadrant. In IEEE
      representation, these bits are as follows:</t>

      <figure align="center" anchor="SLAP-Bits"
                title="SLAP Bits">
          <preamble></preamble>

          <artwork align="left"><![CDATA[
    LSB                MSB
    M  X  Y  Z  -  -  -  -
    |  |  |  |
    |  |  |  +------------ SLAP Z-bit
    |  |  +--------------- SLAP Y-bit
    |  +------------------ X-bit (U/L) = 1 for locally assigned
    +--------------------- M-bit (I/G) (unicast/group)
           ]]></artwork>

          <postamble></postamble>
        </figure>

      <t>The SLAP quardants are:</t>

<texttable title="SLAP Quadrants">
<ttcol align='right'>Quadrant</ttcol>
<ttcol align='left'>Y-bit</ttcol>
<ttcol align='left'>Z-bit</ttcol>
<ttcol align='left'>Local Identifier Type</ttcol>
<ttcol align='left'>Local Identifier</ttcol>
     <c>01</c><c>0</c><c>1</c><c>Extended Local</c><c>ELI</c>
     <c>11</c><c>1</c><c>1</c><c>Standard Assigned</c><c>SAI</c>
     <c>00</c><c>0</c><c>0</c><c>Administratively Assigned</c><c>AAI</c>
     <c>10</c><c>1</c><c>0</c><c>Reserved</c><c>Reserved</c>
</texttable>

      <t>Extended Local Identifier (ELI) derived MAC addresses are based on an
      assigned Company ID (CID), which is 24-bits (including the M, X, Y, and
      Z bits) for 48-bit MAC addresses. This leaves 24-bits for the locally
      assigned address for each CID for unicast (M-bit = 0) and also for
      multicast (M-bit = 1). The CID is assigned by the IEEE RA.</t>

      <t>Standard Assigned Identifier (SAI) derived MAC addresses are
      assigned by a protocol specified in an IEEE 802 standard. For
      48-bit MAC addresses, 44 bits are available. Multiple protocols
      for assigning SAIs may be specified in IEEE standards. Coexistance of
      multiple protocols may be supported by limiting the subspace available
      for assignment by each protocol.</t>

      <t>Adminstratively Assigned Identifier (AAI) derived MAC addresses are
      assigned locally. Administrators manage the space as needed. Note that
      multicast IPv6 packets (<xref target="RFC2464"/>) use a destination address
      starting in 33-33 and this falls within this space and therefore should
      not be used to avoid conflict with IPv6 multicast addresses. For
      48-bit MAC addresses, 44 bits are available.</t>

      <t>The last quandrant is reserved for future use. While they may be used
      for AAI space, administrators should be aware that future specifications
      may define alternate uses that could be incompatible.</t>

    </section>

  </back>
</rfc>
