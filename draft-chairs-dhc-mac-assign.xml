<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="std" docName="draft-bvtm-dhc-mac-assign-00">
  <front>
    <title abbrev="MAC address assignment in DHCPv6">
    Link Layer Addresses Assignment Mechanism for DHCPv6</title>

    <author fullname="Bernie Volz" initials="B" surname="Volz">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>1414 Massachusetts Ave</street>
          <city>Boxborough, MA 01719</city>
          <country>USA</country>
        </postal>
        <email>volz@cisco.com</email>
      </address>
    </author>

    <author fullname="Tomek Mrugalski" initials="T."
            surname="Mrugalski">
      <organization abbrev="ISC">Internet Systems Consortium,
      Inc.</organization>
      <address>
        <postal>
          <street>950 Charter Street</street>
          <city>Redwood City</city>
          <region>CA</region>
          <code>94063</code>
          <country>USA</country>
        </postal>
        <email>tomasz.mrugalski@gmail.com</email>
      </address>
    </author>

    <date year="2018"/>

    <area>Internet</area>

    <workgroup>Dynamic Host Configuration (DHC)</workgroup>

    <keyword>DHCPv6</keyword>

    <keyword>Link-layer</keyword>

    <keyword>assignment</keyword>

    <!--  SECTION 0:  Abstract                      -->

    <abstract>
      <t>In certain environments, e.g. large scale virtualisation, new
      devices are created in automated manner. Such devices typically
      have their link layer (MAC) addresses randomised. With
      sufficient scale the likelihood of collision is not
      acceptable. Therefore an allocation mechanism is required. This
      draft proposes an extension to DHCPv6 that allows a scalable
      approach to link layer address assignments.</t>

    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <!-- 1, line 230-->

      <t>There are several new deployment types that deal with a large
      number of devices that need to initialised. One of them is a
      scenario where VM (virtual machines) are created on a massive
      scale. Typically the new VM instances are assigned a random link
      layer (MAC) address, but that does not scale well due to
      birthday paradox. Another use case are IOT devices. Typically
      there is no need to provide global uniqueness of MAC addresses
      for such devices. On the other hand, huge number of such devices
      would likely exhaust a vendor's OUI (Organisation's Unique
      Identifier) global address space. For those reasons, it is
      desired to have some form of local authority that would be able
      to assign MAC addresses.</t>
         
      <t>The IEEE originally set aside half of the 48-bit MAC Address
      space for local use (where the U/L bit is set to 1). In 2017, the
      IEEE specified an optional specification (IEEE 802c) that divides
      this space into quadrants (Standards Assigned Identifier, Extended
      Local Identifier, Administratively Assigned Identifier, and a
      Reserved quadrant) - more details are in <xref
      target="IEEE802cSummary"/>. The IEEE is also
      working to specify protocols and procedures for assignment of
      locally unique addresses (IEEE 802.1cq). This work may serve
      as one such protocol for assignment. For additional background,
      see <xref target="IEEE-802-Tutorial"/>.</t>

      <t>This document proposes a new mechanism that extends DHCPv6
      operation to handle MAC address assignments.</t>

      <t>Since DHCPv6 (<xref target="RFC3315"/>) is a protocol that can
      allocate various types
      of resources (non-temporary addresses, temporary addresses,
      prefixes, but also many options) and has necessary
      infrastructure to maintain such assignment, it is a good
      candidate for requested functionality.</t>
    </section>

    <section anchor="requirements" title="Requirements">
      <t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be interpreted as
      described in BCP 14 <xref target="RFC2119"/> <xref
      target="RFC8174" /> when, and only when, they
      appear in all capitals, as shown here.</t>

    </section>

    <section anchor="overview" title="Mechanism overview">

      <t>TODO: Describe two use cases: 1) Hypervisor that requests MAC
      address(es) on behalf of the VM to be spawned 2) a new IOT
      device booting up requesting its own MAC address. Might we want
      section(s) similar to how 3315bis section 6 describes current
      DHCPv6 Operational Models? For scenario
      2) cover how DHCP (or IP packets in general) are sent without
      having stable MAC address. Use Temporary MAC address for
      anonymity, IEEE 802.11-02/109r0) (can this be used in other
      networks than 802.11?)</t>

      <t>One of the essential aspects of this mechanism is its
      cumulative nature, especially in the hypervisor scenario. The
      server-client relationship does not look like other DHCP
      transactions. This is especially true in hypervisor scenario. In
      typical environment there would be one server and rather small
      number of hypervisors, possibly even only one. However, over
      time the number of MAC addresses requested by a client will
      likely increase over time as new VMs are spawned.</t>

      <t>Another aspect crucial for efficient design is the
      observation that a single client acting as hypervisor will
      likely use thousands of addresses. Therefore an approach similar
      to what is used for address or prefix assignment (IA container
      with all assigned addresses listed, one option for each address)
      would not work well. Therefore the mechanism operates on MAC
      address ranges, rather than single values. This does not prevent
      the users to treat individual MAC addresses as ranges with just
      one address.</t>

      <section title="Requesting addresses">
        <t>Client sends the requested link-layer address in its packet
        as a hint. Several cases can be considered here. First, if the
        client doesn't have any previous link-layer addresses assigned
        and doesn't have any specific preferences, it can request any
        address, that is represented as values consisting of only
        zeroes.
        </t>

        <t>Client can represent a block of addresses, starting with
        the specified address and followed by a number of addresses
        indicated by extra-addresses field. If that field value is 0,
        then exactly one address is requested.</t>

        <t>Client can request a block of addresses, without specifying
        any particular preferences regarding starting address. This
        can be achieved using link-layer address consisting of all
        zeroes and extra-addresses field specifying the number of
        requested addresses decreased by one.</t>
      </section>

      <section title="Renewing and releasing addresses">
      <t>TODO: How client renews/releases? Make sure that the whole
      block is always renewed/released. Further fragments are not
      allowed.</t>

      <t>TODO:  The growth in hypervisor case. The hypervisor client
      will start with certain number of MAC addresses and then will
      keep asking for more over time. If we go with IAID approach, the
      client will be sending more and more options over time until MTU
      limit is hit. If we decide to go with a single container and
      multiple range options in it, we'll need some sort of compacting
      algorithm.</t>
      </section>

      <section title="Other questions">
      <t>TODO: What should the server do if client asks for X
      addresses, but for whatever reason (limited resources or policy), the
      server is only able to assign Y? Proposed answer: respond with
      a smaller block and add text: client MUST accept the value sent
      by client. If additional addresses are needed, send another
      request (but obey rate limiting).</t>

      <t>TODO: How exactly the Use Temporary MAC address for
      anonymity, IEEE 802.11-02/109r0 works? Can we turn this into a
      way to "upgrade" the temporary address into permanent one? "Yes,
      I confirm your temp address is really unique. You can keep it."</t>
      </section>
    </section>

    <section anchor="option" title="Option definitions">

      <t>TODO: Need to define option formats here. There are 3
      possible approaches. 1) a single MAC address (which isn't
      flexible and would raise the same objections people now have for
      IA_NA) 2) min-max (which seems the most flexible, but has
      unneeded overheard if client requests a signle MAC; 3) do
      assignments with bit lengths, similar to IA_PD (this wouldn't
      work too well, because the address space for a single OUI is
      only 24 bits) and finally 4) define first address + number of
      addresses (which can be zero if only one address is
      needed). This approach has been defined below.</t>


      <figure align="center" anchor="ia-ll-syntax"
              title="IA_LL Option Syntax">
        <artwork align="left"><![CDATA[
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          OPTION_IA_LL         |          option-len           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        iaid (4 octets)                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          t1 (4 octets)                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          t2 (4 octets)                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   .                                                               .
   .                         IA_LL-options                         .
   .                                                               .
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ]]></artwork>
        <postamble></postamble>
      </figure>

        <t>
          <list hangIndent="16" style="hanging">
            <t hangText="option-code">OPTION_IA_LL (tbd1).</t>

            <t hangText="option-len">12 + size of any encapsulated
            options.</t>

            <t hangText="iaid">Identity Association for Link-Layer</t>

            <t hangText="t1">Renewal timer</t>

            <t hangText="t2">Rebind timer</t>

            <t hangText="IA_LL-options">any encapsulated options that
            are specific to this particular IA_LL container. Currently there
            is only one option type defined (LLADDR), but additional
            types may be defined in the future.</t>
          </list>
        </t>


        <figure align="center" anchor="lladdr-syntax"
                title="LLADDR Option Syntax">
          <preamble></preamble>

          <artwork align="left"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          OPTION_LLADDR        |          option-len           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       link-layer-type         |        link-layer-len         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     link-layer-address                        |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      extra-addresses                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      valid-lifetime                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.                                                               .
.                      LLADDR-options                           .
.                                                               .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          <postamble></postamble>
        </figure>

        <t>
          <list hangIndent="16" style="hanging">
            <t hangText="option-code">OPTION_LLADDR (tbd2).</t>

            <t hangText="option-len">16 + link layer length
            (typically 6) + any LLADDR options. Assuming a typical
            link-layer address of 6 is used and there are no extra
            options, length should be equal to 22.</t>

            <t hangText="link-layer-type">..</t>

            <t hangText="link-layer-len">specifies length of the
            link-layer address (typically 6)</t>

            <t hangText="link-layer-address">Specific value of
            link-layer address that is being requested. A special case
            of address consisting of only zeroes means any
            address. This value can be only sent by a client that
            requests a new block.</t>

            <t hangText="extra-addresses">Number of additional
            addresses that follow address specified in
            link-layer-address. For requesting a single address, use
            0. For example: link-layer-address: 02:04:06:08:0a and
            extra-addresses 3 designates a block of 4 addresses,
            starting from 02:04:06:08:0a (inclusive) and ending with
            02:04:06:08:0d (inclusive).</t>

            <t hangText="valid-lifetime">expressed in seconds</t>

            <t hangText="LLADDR-options">any encapsulated options that
            are specific to this particular LLBLOCK. Currently there
            are no such options defined, but they may appear in the future.</t>
          </list>
        </t>

    </section>

    <section anchor="client" title="Client behaviour">
      <t>TODO: We need start this section by clearly defining what
      'client' means in this context (either hypervisor acting on
      behalf of the client to be spawned or the IOT device acting on
      its own behalf).</t>
    </section>

    <section anchor="server" title="Server behaviour">
      <t>TODO: Need to describe server operation. Likely also recommend
      assigning MAC addresses from an appropriate quandrant (see
      Appendix).</t>
    </section>

    <section anchor="iana" title="IANA Considerations">
      <t>IANA is kindly requested to assign new value for options
      OPTION_LL (tbd1) and OPTION_LLADDR (tbd2) and add those values
      to the DHCPv6 Option Codes registry maintainted at
      http://www.iana.org/assignments/dhcpv6-parameters.</t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>TODO:</t>
    </section>

    <section anchor="privacy" title="Privacy Considerations">
      <t>TODO: </t>
    </section>

  </middle>

  <back>
    <references title="Normative References">

      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.3315'?>
      <?rfc include='reference.RFC.8174'?>
    </references>

    <references title="Informative References">

      <?rfc include='reference.RFC.2464'?>
      <reference anchor="IEEE-802-Tutorial">
        <front>
          <title>
              Emerging IEEE 802 Work on MAC Addressing,
              https://datatracker.ietf.org/meeting/96/materials/slides-96-edu-ieee802work-0/
              </title>

          <author fullname="Pat Thaler" initials="P" surname="Thaler"/>

          <date />
        </front>
      </reference>
         
      <reference anchor="IEEEStd802c-2017">
        <front>
          <title>
              IEEE Standard for Local and Metropolitan Area Networks: Overview and Architecture,
              Amendment 2: Local Medium Access Control (MAC) Address Usage, IEEE Std 802c-2017
              </title>

          <author>
            <organization>IEEE Computer Society</organization>
          </author>

          <date />
        </front>
      </reference>         

    </references>
       
    <section anchor="IEEE802cSummary" title="IEEE 802c Summary">
         
      <t>This appendix provides a brief summary of IEEE802c from
           <xref target="IEEEStd802c-2017"/>.</t>  
         
      <t>The original IEEE 802 specifications assigned half of the 48-bit MAC address
      space to local use -- these addresses have the U/L bit set to 1 and are locally
      administered with no imposed structure.</t>
           
      <t>In 2017, the IEEE issued the 802c specification which defines a new "optional
      Structured Local Address Plan (SLAP) that specifies different assignment
      approaches in four specified regions of the local MAC address space." Under this
      plan, there are 4 SLAP quadrants that use different assignment policies.</t>
           
      <t>The first octet of the MAC address Z and Y bits define the quadrant. In IEEE
      representation, these bits are as follows:</t>
           
      <figure align="center" anchor="SLAP-Bits"
                title="SLAP Bits">
          <preamble></preamble>
           
          <artwork align="left"><![CDATA[
    LSB                MSB
    M  X  Y  Z  -  -  -  -  
    |  |  |  |
    |  |  |  +------------ SLAP Z-bit
    |  |  +--------------- SLAP M-bit
    |  +------------------ X-bit (U/L) = 1 for locally assigned
    +--------------------- M-bit (I/G) (unicast/group)
           ]]></artwork>

          <postamble></postamble>
        </figure>
         
      <t>The SLAP quardants are:</t>
      
<texttable title="SLAP Quadrants">
<ttcol align='right'>Quadrant</ttcol>
<ttcol align='left'>Y-bit</ttcol>
<ttcol align='left'>Z-bit</ttcol>
<ttcol align='left'>Local Identifier Type</ttcol>
<ttcol align='left'>Local Identifier</ttcol>
     <c>01</c><c>0</c><c>1</c><c>Extended Local</c><c>ELI</c>
     <c>11</c><c>1</c><c>1</c><c>Standard Assigned</c><c>SAI</c>
     <c>00</c><c>0</c><c>0</c><c>Administratively Assigned</c><c>AAI</c>
     <c>10</c><c>1</c><c>0</c><c>Reserved</c><c>Reserved</c>
</texttable>

      <t>Extended Local Identifier (ELI) derived MAC addresses are based on an
      assigned Company ID (CID), which is 24-bits (including the M, X, Y, and
      Z bits) for 48-bit MAC addresses. This leaves 24-bits for the locally
      assigned address for each CID for unicast (M-bit = 0) and also for
      multicast (M-bit = 1). The CID is assigned by the IEEE RA.</t>
      
      <t>Standard Assigned Identifier (SAI) derived MAC addresses are
      assigned by a protocol specified in an IEEE 802 standard. For
      48-bit MAC addresses, 44 bits are available. Multiple protocols
      for assigning SAIs may be specified in IEEE standards. Coexistance of
      multiple protocols may be supported by limiting the subspace available
      for assignment by each protocol.</t>
       
      <t>Adminstratively Assigned Identifier (AAI) derived MAC addresses are
      assigned locally. Administrators manage the space as needed. Note that
      multicast IPv6 packets (<xref target="RFC2464"/>) use a destination address
      starting in 33-33 and this falls within this space and therefore should
      not be used to avoid conflict with IPv6 multicast addresses. For
      48-bit MAC addresses, 44 bits are available.</t>
            
      <t>The last quandrant is reserved for future use. While they may be used
      for AAI space, administrators should be aware that future specifications
      may define alternate uses that could be incompatible.</t>
           
    </section>

  </back>
</rfc>
